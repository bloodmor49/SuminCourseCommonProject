
///////////////////////////// 1. Job, Builders /////////////////////////////////

BUILDER

lifecycleScope.launch - формируется благодаря создателю корутин. builder. Запуск через launch.
При помощи билдера мы запускаем все корутины.

JOB

Допустим у нас есть два процесса, которые загружаются с разной скоростью.
Нам нужно, чтобы по окончанию обоих процессов что - то произошло.
Для этого есть интерфейс Job, как результат lifeCycleScope.
Принцип довольно простой и он идет дальше.
Фактически .join() ожидает

///////////////////////////// Общий принцип работы /////////////////////////////////

1. Первая загрузка - результат jobCity:
                val jobCity = lifecycleScope.launch ////

2. Вторая параллельная загрузка - результат jobWeather:
                val jobWeather = lifecycleScope.launch ////


3. И далее мы создаем третий поток, который ждет завершения первых двух, после
чего начинает выполнять свои задачи.

Стоит отметить, что все три корутины запускаются практически сразу (миллисикунды разницы):

   lifecycleScope.launch {
                   //ждет, пока нужные потоки завершатся.
                   //у джобов есть ряд других методов, можно проверить активно оно или нет и тд.
                   jobCity.join()
                   jobWeather.join()

                   //наши задачи.
                   viewBinding.progressBarOfDownloading.isVisible = false
                   viewBinding.btnDownload.isEnabled = true
               }
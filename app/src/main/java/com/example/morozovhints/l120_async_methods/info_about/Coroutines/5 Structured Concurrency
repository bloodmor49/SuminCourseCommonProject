
///////////////////////////// 5 Structured Concurrency /////////////////////////////////

Structured Concurrency - набор правил по которым работают с корутинами.

1 правило - каждая корутина должна быть запущена внутри какого - то скоупа с опред. жизн. циклом.
Т.е. нельзя её вызвать в обычном методе. Нужно делать скоуп и тд.

2 правило - все корутины запускаются в виде иерархии объектов job.
Нас интересует объект Job - он на вершине иерархии.

3 правило - до тех пор, пока Job - дети не закончат свою работу, job - отец не должен быть закрыт.

4 правило - если Job родитель отменяется, то все дочерние корутины тоже должны отменяться.

5 правило - если в одной из Job ошибка, то она передается вверх по иерархии.
Если родитель не умеет его обрабатывать, то будешь краш. Они обрабатываются Exception Handler.
Наследники по большей части тоже прекращают работу.

///////////////////////////// Общий принцип работы /////////////////////////////////

Про JOB.

1. Сначала создаем родительский job:
    private val parentJob = Job()

    Есть также SupervisorJob(). Отличие - если используем Job, и есть ошибка, то все скоупы отвалятся.
    Супервайзер сломает только Job с ошибкой, остальные корутины трогаться не будут.
    Такой используется у ViewModelJob.

2. После вызова scope.launch() создается его сынок job. Конкретно здесь их два.
(Проверка через parentJob.children.contains(childJob1).toString())

            val childJob1 = corutineScope.launch {
                delay(3000)}
            val childJob2 = corutineScope.launch {
                delay(3000) }

3 правило проверка:

    thread {
                Thread.sleep(1000)
                parentJob.cancel()
                Log.i(LOG_TAG,"Parent job is active: ${parentJob.isActive}")
            }

4 правило проверка:

Добавляем в сынка отмену другого сынка             childJob1.cancel()
